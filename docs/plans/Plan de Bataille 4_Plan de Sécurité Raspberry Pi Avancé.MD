PLAN DE BATAILLE 4 - PROTOCOLE DE DÉFENSE ET D'ARCHITECTURE : PROJET CLERIVO V7.0 (OPÉRATION FORTERESSE)
1. Introduction Stratégique : La Souveraineté des Données en Environnement Hostile
1.1 Le Paradigme "Local First" face aux Menaces Modernes
Le projet Clerivo incarne une philosophie singulière dans le paysage actuel du SaaS immobilier : le "Local First". En choisissant d'héberger l'intelligence et les données critiques sur une infrastructure locale basée sur un Raspberry Pi 5, l'architecture s'affranchit de la dépendance aux géants du cloud public, garantissant une souveraineté totale sur les données sensibles des mandats et des estimations.1 Cependant, cette indépendance transfère l'intégralité de la charge de sécurité sur l'équipe de développement. Contrairement à une infrastructure AWS ou Azure où la sécurité physique, la redondance électrique et la protection périmétrique sont gérées par le fournisseur, Clerivo doit ériger ses propres remparts.
L'analyse approfondie du dossier technique et des contraintes opérationnelles révèle une surface d'attaque hybride et complexe. Le système doit conjuguer une accessibilité web moderne pour trois clients distants avec une infrastructure matérielle physiquement vulnérable — un micro-ordinateur et une clé USB stockant l'intégralité du capital informationnel de l'agence. La protection de ce système ne peut se satisfaire de mesures superficielles ; elle exige une stratégie de "Défense en Profondeur" (Defense in Depth) où chaque couche de l'architecture — du contrôleur disque au pare-feu applicatif — est conçue en supposant que la couche précédente a déjà cédé.
1.2 Modélisation des Menaces Spécifiques à l'Immobilier
Dans le secteur immobilier, la donnée vaut de l'or. Les fichiers clients, les estimations pré-mandat et les détails des transactions en cours sont des cibles privilégiées pour la concurrence déloyale ou le chantage numérique (ransomware).
L'architecture actuelle présente trois vecteurs de risque critiques qui structureront ce plan de bataille :
1.	Le Vecteur Physique (Critique) : La contrainte stipulant que "toutes les données sont stockées dans la clé USB" [User Query] crée un point de défaillance unique (SPOF) et un risque de vol majeur. Une clé USB est facilement subtilitée, perdue ou corrompue. Sans chiffrement rigoureux, la perte du support physique équivaut à une divulgation publique des données.
2.	Le Vecteur Réseau : L'ouverture du service à trois clients distants implique d'exposer le serveur au réseau public. Les méthodes traditionnelles de redirection de port (Port Forwarding) exposeraient l'IP résidentielle de l'hébergement et le port du serveur aux scanners de vulnérabilités qui cartographient Internet en permanence.
3.	Le Vecteur Applicatif et Logique : L'utilisation de SQLite en mode multi-utilisateurs, bien que performante pour cette échelle, pose des défis de concurrence et d'intégrité.2 De plus, l'intégration de l'IA (OpenAI) dans le traitement des emails 1 introduit des risques d'injection de prompt et de fuite de données si les "Gatekeepers" ne sont pas hermétiques.
Ce rapport déploie une stratégie exhaustive de sécurisation, transformant le Raspberry Pi en une "Black Box" numérique, impénétrable physiquement et invisible sur le réseau public, tout en garantissant la fluidité opérationnelle requise par les agents immobiliers.
________________________________________2. La Citadelle de Données : Sécurité Physique et Chiffrement du Stockage
La protection des données au repos (Data at Rest) constitue la fondation inamovible de notre stratégie. Dans le contexte de Clerivo, où la base de données réside sur un support amovible, nous devons considérer que l'adversaire a un accès physique au matériel. La réponse à cette menace est le chiffrement intégral du disque (Full Disk Encryption) couplé à une gestion des clés adaptée à un serveur "Headless" (sans écran ni clavier).
2.1 Architecture de Chiffrement LUKS et Interdépendance Matérielle
Le standard industriel pour le chiffrement sous Linux est LUKS (Linux Unified Key Setup). C'est la technologie que nous déploierons pour sanctuariser la clé USB. Cependant, le défi majeur réside dans le démarrage automatique : comment déverrouiller le disque au boot sans qu'un humain ne tape une phrase de passe, tout en empêchant un voleur de lire les données s'il dérobe la clé USB?
La solution réside dans la création d'une interdépendance cryptographique entre le Raspberry Pi (la carte SD) et le stockage (la clé USB). L'objectif est de faire en sorte que la clé USB soit illisible sans la carte SD spécifique, et que la carte SD soit inutile sans la clé USB associée.3
2.1.1 Le Mécanisme du Keyfile "Headless"
Au lieu d'une phrase de passe mémorisée, nous utiliserons un fichier clé (Keyfile) binaire à haute entropie. Ce fichier agira comme une clé physique numérique.
Le processus technique, illustré par la logique des systèmes de fichiers chiffrés, suit une séquence précise lors du démarrage du Raspberry Pi. Initialement, le système amorce son noyau depuis la carte SD (partition /boot). Une fois le système de fichiers racine (/) monté en lecture seule, le processus de démarrage recherche un fichier clé spécifique, par exemple /root/clerivo_master.key. Ce fichier n'existe que sur la carte SD. Le sous-système de chiffrement cryptsetup lit ce fichier et tente de l'utiliser pour déverrouiller le volume LUKS présent sur la clé USB connectée. Si la correspondance est validée, le volume est déchiffré et monté sur /srv/clerivo/data, rendant la base de données accessible à l'application.
Cette architecture offre une sécurité robuste contre le vol opportuniste. Si un intrus débranche la clé USB et part avec, il ne possède que des données chiffrées avec l'algorithme AES-256-XTS, statistiquement indiscernables du bruit aléatoire et impossibles à briser par force brute sans la clé. Si l'intrus vole uniquement le Raspberry Pi, il possède la clé de déchiffrement mais pas les données. La sécurité est compromise uniquement si l'ensemble du matériel est dérobé, scénario que nous mitigerons par la sécurité logicielle et les sauvegardes distantes.
2.1.2 Implémentation Technique et Résilience
La mise en œuvre de ce chiffrement sur un Raspberry Pi 5 nécessite une rigueur absolue pour éviter de rendre le système non-démarrable (brick). L'utilisation de l'identifiant unique universel (UUID) des partitions est impérative.3 Sur un Raspberry Pi, l'ordre d'attribution des lettres de lecteur (/dev/sda, /dev/sdb) peut changer selon les périphériques connectés au démarrage. L'UUID garantit que le système cible toujours le bon volume physique, quel que soit le port USB utilisé.
La configuration du fichier /etc/crypttab doit expliciter le lien entre le volume chiffré et le fichier clé stocké sur la SD. Parallèlement, le fichier /etc/fstab, responsable du montage des disques, doit impérativement inclure l'option nofail.3 Cette directive est critique pour la maintenance : si la clé USB est défaillante, absente ou corrompue, l'option nofail permet au Raspberry Pi de poursuivre son démarrage jusqu'à rendre le service SSH disponible. Sans cette option, le système se bloquerait en mode d'urgence (Emergency Mode), nécessitant de connecter un écran et un clavier pour le dépannage, ce qui violerait le principe de gestion à distance.
2.2 Gestion de l'Usure et Optimisation des Performances I/O
Les clés USB grand public, et même certains SSD externes, ne sont pas conçus pour supporter la fréquence d'écriture intensive d'une base de données transactionnelle comme SQLite, surtout lorsqu'elle est configurée en mode WAL (Write-Ahead Logging) pour la performance multi-utilisateurs.2 Chaque transaction entraîne une écriture dans le journal, ce qui peut saturer le contrôleur de la clé USB et user prématurément les cellules de mémoire flash.
Pour contrer ce risque physique, nous devons appliquer une stratégie de ségrégation des écritures. Les données volatiles et les journaux systèmes doivent être déportés hors de la clé USB de stockage.
1.	Logs en RAM (tmpfs) : Les fichiers de logs de l'application (pm2 logs) et du système (/var/log) sont extrêmement verbeux et génèrent des milliers de petites écritures. Il est recommandé de monter ces répertoires en mémoire vive (RAM) via tmpfs ou d'utiliser Log2Ram. Sur un Raspberry Pi 5 avec 16Go de RAM, allouer 500Mo aux logs est négligeable pour la mémoire mais salutaire pour la durée de vie du stockage.
2.	Configuration SQLite Adaptée : Bien que le mode WAL soit nécessaire pour la concurrence, nous ajusterons la directive PRAGMA synchronous de SQLite à NORMAL au lieu de FULL.5 Ce réglage permet au système d'exploitation de tamponner certaines écritures disque, réduisant la pression physique sur la clé USB sans compromettre significativement l'intégrité des données en cas de crash applicatif (seul un crash complet de l'OS ou une coupure de courant au moment précis de l'écriture présenterait un risque minime, risque mitigé par l'onduleur ou une alimentation stable).
________________________________________3. Le Bouclier Réseau : Invisibilité et Connectivité Sécurisée
L'ouverture du service Clerivo à trois clients distants ne doit pas se faire au prix de la sécurité du réseau local de l'hébergeur. L'approche classique consistant à ouvrir des ports sur la box internet (Port Forwarding) est obsolète et dangereuse, exposant le serveur aux scanners de bots, aux attaques DDoS et aux tentatives d'exploitation de vulnérabilités Zero-day sur le serveur web.
3.1 Cloudflare Tunnel : La Stratégie de l'Invisibilité
Pour répondre à l'exigence de sécurité maximale sans imposer de complexité technique aux clients (comme l'installation d'un VPN type WireGuard), la solution optimale est l'utilisation de Cloudflare Tunnel (anciennement Argo Tunnel). Cette technologie inverse le paradigme de connexion.7
Au lieu d'ouvrir une porte d'entrée (port entrant), le Raspberry Pi initie une connexion sortante sécurisée et persistante vers le réseau mondial de Cloudflare via le démon cloudflared.
Cette architecture offre des avantages stratégiques décisifs :
●	Zéro Port Ouvert : Le pare-feu du routeur et du Pi peut être configuré pour bloquer 100% du trafic entrant (deny incoming). Le Pi devient invisible sur Internet ; il n'a pas d'IP publique accessible directement.
●	Chiffrement SSL/TLS Automatique : Cloudflare gère la terminaison SSL. Le trafic entre le client et Cloudflare est chiffré, et le trafic dans le tunnel vers le Pi l'est également. Cela répond à la règle stricte du HTTPS obligatoire mentionnée dans les documents internes 1 sans avoir à gérer des certificats Let's Encrypt complexes et leur renouvellement sur le Pi lui-même.
●	Protection DDoS et WAF : En passant par Cloudflare, Clerivo bénéficie d'un pare-feu applicatif web (WAF) de classe entreprise. Nous configurerons des règles de géolocalisation strictes pour bloquer tout trafic ne provenant pas des pays cibles (ex: Suisse, France), éliminant ainsi 99% du bruit de fond malveillant mondial.
Bien que WireGuard offre des performances brutes légèrement supérieures et une souveraineté totale (pas d'intermédiaire), il échoue sur le critère de l'expérience utilisateur pour un SaaS.9 Demander à un agent immobilier de lancer un VPN avant d'accéder à son CRM est une friction qui nuit à l'adoption. Cloudflare Tunnel offre une expérience transparente : l'utilisateur accède simplement à https://app.clerivo.ch et le tunnel gère le reste.
3.2 Défense Périmétrique Locale : UFW et Fail2ban
Même si le tunnel assure la sécurité externe, le principe de défense en profondeur exige une sécurité interne rigoureuse pour parer aux mouvements latéraux (un autre appareil compromis sur le réseau local) ou aux erreurs de configuration.
Le Pare-feu UFW (Uncomplicated Firewall) : La configuration du pare-feu sur le Raspberry Pi doit être draconienne.10 La politique par défaut sera le refus total de toute connexion entrante. Seules les exceptions vitales seront tolérées. Concrètement, puisque cloudflared communique avec l'application via la boucle locale (localhost:3010), le port 3010 ne doit même pas être ouvert sur l'interface réseau locale (eth0 ou wlan0). La seule exception sera le port SSH (22), et celui-ci sera restreint strictement aux adresses IP du réseau local (ex: 192.168.1.0/24). Cela empêche toute tentative de connexion SSH depuis l'extérieur du bâtiment, même si le tunnel était compromis.
La Sentinelle Active Fail2ban : Fail2ban est un système de prévention d'intrusion qui analyse les journaux (logs) en temps réel pour détecter des comportements suspects.12 Nous le déploierons sur deux fronts :
1.	Protection SSH : Bien que l'accès soit local, Fail2ban bannira temporairement toute IP locale tentant un bruteforce sur le port SSH.
2.	Protection Applicative (Node.js) : C'est ici que la sécurité devient "intelligente". Nous configurerons Node.js pour qu'il écrive des logs spécifiques lors d'événements de sécurité (ex: "Failed login attempt for user X", "Unauthorized access to /admin"). Fail2ban surveillera ce fichier de log. Après 5 tentatives de connexion échouées en moins de 10 minutes, Fail2ban communiquera avec l'API de Cloudflare pour bannir l'IP de l'attaquant directement au niveau du cloud, avant même qu'elle ne touche à nouveau le serveur. C'est une boucle de rétroaction défensive automatisée.
3.3 Durcissement SSH et Authentification par Clés
L'accès SSH est la "porte de service" du serveur. Sa sécurisation est vitale. L'authentification par mot de passe pour SSH sera totalement désactivée.13 Seule l'authentification par clé cryptographique (ED25519, plus sûr et rapide que RSA) sera autorisée. Cette mesure rend les attaques par dictionnaire mathématiquement inopérantes. De plus, pour les sessions d'administration critiques, nous pouvons ajouter une couche de 2FA sur SSH (via module PAM Google Authenticator), obligeant l'administrateur à valider une notification sur son mobile pour obtenir l'accès root, même avec la bonne clé SSH.
3.4 Le Swiss Link (Tunnel mTLS pour GPU Sidecar)
Pour l'extension de puissance requise par le module "Le Visionnaire", une connexion sécurisée par authentification mutuelle (mTLS) est établie vers le Sidecar GPU en Suisse. Contrairement au tunnel Cloudflare (accès client), ce lien est une autoroute privée "Machine-to-Machine" garantissant que seul votre Raspberry Pi peut ordonner un calcul au GPU déporté, excluant tout risque d'interception ou d'usage tiers des ressources cloud.________________________________________4. Phase 3 : Gestion des Identités et Contrôle d'Accès (IAM)
La sécurité du périmètre ne suffit pas si la porte d'entrée de l'application est vulnérable. Avec jusqu'à trois clients connectés simultanément, et potentiellement plus à l'avenir, la gestion des sessions doit passer d'un modèle artisanal à un standard industriel.
4.1 L'Impératif de l'Authentification à Double Facteur (2FA)
Dans le contexte actuel, un simple couple email/mot de passe est considéré comme compromis par défaut. Pour un outil gérant des données financières et immobilières, l'authentification à deux facteurs (2FA) via TOTP (Time-Based One-Time Password) n'est pas une option, c'est une obligation.
Les recherches indiquent que la librairie speakeasy, bien que populaire, n'est plus activement maintenue.15 Pour garantir la pérennité du projet Clerivo, nous nous orienterons vers des bibliothèques plus modernes et auditées comme otpauth ou @simplewebauthn. Cependant, la logique cryptographique reste la même. Le serveur et le téléphone du client (via Google Authenticator ou Authy) partagent un secret. Ce secret permet de générer un code éphémère valide 30 secondes.
Architecture de Sécurité du Secret 2FA : Une règle d'or doit être respectée : le secret TOTP (la clé privée de l'utilisateur) ne doit jamais être stocké en clair dans la base de données SQLite.15 Si la base de données fuyait, tous les 2FA seraient compromis. Nous appliquerons un chiffrement de ce secret au niveau applicatif (AES-256) avant l'insertion en base, utilisant une clé de chiffrement maîtresse injectée via les variables d'environnement du serveur (et non écrite dans le code).
4.2 Séquence d'Authentification Renforcée
L'implémentation du login ne doit pas délivrer le jeton de session (JWT) tant que la 2FA n'est pas validée. C'est une erreur classique de délivrer un accès partiel après le mot de passe.
La séquence correcte, détaillée ci-dessous, crée un sas de sécurité étanche.

 

Comme l'illustre le diagramme, le serveur valide d'abord le mot de passe (haché avec Argon2 pour résister aux attaques GPU). Si valide, il ne renvoie pas un JWT d'accès, mais un "jeton temporaire de 2FA" (d'une durée de vie de 2 minutes). Ce jeton permet uniquement d'appeler l'endpoint de vérification du code TOTP. Ce n'est qu'après la validation réussie du code à 6 chiffres que le véritable JWT, contenant les droits d'accès et l'identité de l'utilisateur, est signé et envoyé. Cette segmentation neutralise totalement les attaques où le mot de passe seul a été volé.
4.3 Contrôle de Concurrence et Sécurité des Sessions
Pour respecter la contrainte "jusqu'à 3 clients", nous ne pouvons pas nous reposer sur la bonne volonté des utilisateurs. Le système doit imposer techniquement cette limite.
Nous utiliserons un stockage de session en mémoire (ou une table sessions dans SQLite si la persistance au redémarrage est requise). À chaque connexion réussie, le système vérifie le nombre de sessions actives pour le compte de l'agence. Si le seuil est atteint, la politique de sécurité sera "Last-In, Winner" : la connexion la plus ancienne est révoquée pour laisser place à la nouvelle, ou alternativement, la nouvelle est bloquée avec un message explicite.
De plus, chaque JWT sera lié à une empreinte numérique (Fingerprint) du navigateur et de l'IP. Si un jeton est intercepté (Session Hijacking) et utilisé depuis une IP différente ou un navigateur différent, le serveur détectera l'anomalie et invalidera immédiatement la session, forçant une ré-authentification complète.
________________________________________5. Intégrité des Données et Architecture Base de Données
Le choix de SQLite pour un SaaS multi-clients est audacieux mais viable avec une configuration experte. Contrairement aux bases de données client-serveur (PostgreSQL, MySQL) qui gèrent la concurrence via des processus lourds, SQLite est une librairie intégrée au processus applicatif. Si mal configurée, elle peut devenir un goulot d'étranglement majeur ou une source de corruption de données.
5.1 Optimisation Avancée du Mode WAL (Write-Ahead Logging)
Le mode par défaut de SQLite (journal de rollback) verrouille l'intégralité de la base de données pendant une écriture, bloquant toutes les lectures. Avec 3 clients actifs simultanément sur des tâches d'écriture (ex: sauvegarde de brouillons d'emails, mise à jour de statuts), cela provoquerait des erreurs SQLITE_BUSY ou database locked.2
Le mode WAL (Write-Ahead Logging) est la réponse technique. Il permet aux lecteurs de ne pas bloquer les rédacteurs et inversement. Cependant, pour que cela fonctionne de manière fluide sur un stockage USB potentiellement lent, une configuration précise est requise dans database.js 5 :
1.	PRAGMA journal_mode = WAL; : Active le mode concurrent.
2.	PRAGMA busy_timeout = 5000; : C'est le filet de sécurité. Au lieu d'échouer immédiatement si la base est verrouillée, SQLite attendra jusqu'à 5000ms qu'elle se libère. Pour l'utilisateur humain, une latence de 200ms est imperceptible, mais pour le système, c'est suffisant pour laisser passer une écriture concurrente.
3.	PRAGMA foreign_keys = ON; : Essentiel pour garantir l'intégrité référentielle des données relationnelles complexes du CRM (liens entre Clients, Messages, et Biens).
5.2 Stratégie de Sauvegarde "3-2-1" : Rclone et le Chiffrement Distant
Stocker les données uniquement sur une clé USB est un risque inacceptable. Une stratégie de sauvegarde robuste suit la règle du 3-2-1 : 3 copies, sur 2 supports différents, dont 1 hors site. Pour Clerivo, nous utiliserons l'outil Rclone, le "couteau suisse" du stockage cloud.16
L'innovation de cette stratégie réside dans la fonctionnalité Rclone Crypt.18 Nous ne ferons pas confiance au fournisseur de cloud (Google Drive, AWS S3 ou autre) pour la confidentialité. Rclone chiffrera les sauvegardes à la volée, sur le Raspberry Pi, avant de les envoyer vers le cloud. Le fournisseur ne recevra que des blobs de données inintelligibles.
Le cycle de sauvegarde automatisé (Cron) :
Chaque nuit, un script exécutera les tâches suivantes :
1.	Snapshot Atomique : Utilisation de l'API .backup de SQLite pour créer une copie instantanée et cohérente de la base de données vers un fichier temporaire. Il est crucial de ne jamais copier le fichier .db directement pendant que l'application tourne, sous peine de corruption.
2.	Archivage Chiffré : Compression de ce snapshot et chiffrement via Rclone.
3.	Synchronisation : Envoi vers le stockage distant (Cloud).
4.	Rétention : Rotation des sauvegardes locales (garder 7 jours) et distantes (garder 30 jours) pour permettre une récupération en cas de corruption silencieuse découverte tardivement.
5.3 Assainissement des Données et Prévention des Injections
L'analyse des snippets de code fournis 1 montre l'utilisation de requêtes paramétrées (?), ce qui est la défense de base contre les injections SQL. Cependant, pour une application exposée, cela ne suffit pas. Nous devons implémenter une validation stricte des schémas de données à l'entrée de l'API. L'utilisation d'une librairie comme Zod ou Joi permet de définir des contrats stricts pour chaque champ (ex: "l'email doit être un email valide", "le nom ne doit pas contenir de script"). Si une donnée ne correspond pas au schéma, elle est rejetée avant même d'atteindre la base de données. Cela protège non seulement contre les attaques, mais aussi contre la corruption de données due à des bugs frontend.
________________________________________6. Sécurité Applicative et Logique Métier
Au-delà de l'infrastructure, le code Node.js lui-même doit être durci. C'est la dernière ligne de défense.
6.1 Le "Gatekeeper" Intelligent et la Protection des Coûts
L'intégration de l'IA pour traiter les emails 1 introduit un risque financier et de sécurité. Envoyer du spam ou des emails malveillants à l'API OpenAI gaspille des crédits et peut exposer le modèle à des contextes toxiques. Le module emailService.js doit être renforcé par un système de "Gatekeeper" à plusieurs niveaux :
1.	Filtrage Statique : Listes noires d'expéditeurs, vérification des en-têtes SPF/DKIM pour rejeter les mails spoofés.
2.	Analyse Heuristique Légère : Avant d'appeler GPT-4, une analyse locale (regex ou algorithme Bayésien simple type mailparser) doit déterminer si l'email est un vrai lead immobilier ou une newsletter. Seuls les emails à "haute probabilité de lead" passent le filtre.
3.	Sanitisation HTML : Les emails contiennent souvent du HTML malveillant (pixels de tracking, scripts). Le contenu doit être nettoyé avec une librairie comme dompurify ou sanitize-html avant d'être stocké ou affiché dans l'interface React, pour prévenir les attaques XSS (Cross-Site Scripting).
6.2 Durcissement du Serveur Express (Helmet)
Le serveur web doit annoncer ses politiques de sécurité aux navigateurs des clients. L'intégration du middleware Helmet dans Express est indispensable. Il configure automatiquement une douzaine d'en-têtes HTTP critiques :
●	HSTS (Strict-Transport-Security) : Force le navigateur à n'utiliser que le HTTPS, empêchant les attaques de déclassement (downgrade attacks).
●	X-Content-Type-Options : Empêche le navigateur de "deviner" le type de fichier, bloquant certaines attaques par upload de fichiers polymorphes.
●	CSP (Content Security Policy) : Définit quelles sources de scripts et d'images sont autorisées, neutralisant la plupart des attaques XSS et d'injections de données.
6.3 Gestion des Erreurs et Obfuscation
Les logs d'erreurs actuels 1 sont extrêmement détaillés, affichant des traces de pile (stack traces) complètes. En développement, c'est utile. En production, c'est une fuite d'information qui révèle l'architecture interne à un attaquant. Nous implémenterons un middleware de gestion d'erreurs global qui intercepte toutes les exceptions. Il enregistrera les détails complets dans les logs locaux (protégés et surveillés par Fail2ban) mais renverra au client une réponse générique et aseptisée : { "error": "Une erreur interne est survenue", "reference": "ERR-12345" }.
6.4 Le Module "Sanitizer" (Anonymisation à la Source)
Afin de respecter strictement la nLPD lors de l'usage du Sidecar GPU, un processus de "Sanitisation" local est obligatoire. Avant toute sortie du réseau local, les fichiers multimédias subissent :
1.	Strip-Metadata : Suppression radicale des tags EXIF (coordonnées GPS du bien, modèle d'appareil). 2. Neural Blur : Identification et floutage automatique des éléments identifiables (plaques d'immatriculation, visages, photos personnelles sur les murs) via un modèle léger s'exécutant sur le CPU du Pi. 
________________________________________7. Plan de Maintenance et Continuité d'Activité
La sécurité n'est pas un état figé, c'est un processus dynamique. Le Raspberry Pi doit être capable de s'auto-maintenir.
7.1 Mises à jour Autonomes (Unattended Upgrades)
Le système d'exploitation (Raspberry Pi OS / Debian) découvre régulièrement de nouvelles vulnérabilités. Attendre une intervention manuelle est risqué. Nous installerons et configurerons le paquet unattended-upgrades pour installer automatiquement les mises à jour de sécurité critiques, sans intervention humaine. Le système sera configuré pour redémarrer automatiquement à 04h00 du matin si une mise à jour du noyau l'exige, minimisant l'impact sur les utilisateurs.11
7.2 Procédure de Récupération "Break Glass"
Le risque zéro n'existe pas. Si le Raspberry Pi ne démarre plus (corruption de la carte SD, fréquente sur ces appareils) ou si la clé USB échoue, une procédure de reprise après sinistre (PRA) doit être prête.
1.	L'Image Maître : Conserver une image disque clonée de la carte SD (configurée mais sans données clients) sur un stockage sécurisé hors ligne.
2.	Restauration Rapide : En cas de panne SD, il suffit de flasher cette image sur une nouvelle carte. Comme le fichier Keyfile est inclus dans cette image, le nouveau système pourra immédiatement déverrouiller et monter la clé USB de données existante.
3.	Récupération Totale : En cas de perte de la clé USB, la procédure consiste à initialiser une nouvelle clé, puis à utiliser le script de restauration Rclone pour redescendre la dernière sauvegarde chiffrée depuis le cloud, la déchiffrer et repeupler la base de données.
________________________________________8. Conclusion et Synthèse Opérationnelle
Ce plan de bataille élève le projet Clerivo bien au-delà d'un simple prototype. Il transforme une contrainte matérielle forte (Raspberry Pi, stockage USB) en une forteresse numérique. En chiffrant le "cœur" physique (LUKS), en rendant le serveur invisible sur le réseau (Cloudflare Tunnel), en verrouillant les accès (2FA) et en assurant la résilience des données (WAL + Rclone), nous atteignons un niveau de sécurité comparable, voire supérieur sur certains aspects de confidentialité, aux solutions SaaS standard du marché.
L'exécution de ce plan demande de la rigueur, mais elle est la condition sine qua non pour opérer un service professionnel hébergeant des données immobilières sensibles. La confiance des clients de Clerivo reposera sur cette infrastructure invisible mais inébranlable.
Sources des citations
1.	Copie de Clerivo_Regles_Travail_v1_3.txt
2.	SQLITE with WAL (multiuser) mode: behavior that disappoints me - Web - Xojo Forum, consulté le février 1, 2026, https://forum.xojo.com/t/sqlite-with-wal-multiuser-mode-behavior-that-disappoints-me/29211
3.	Raspberry Pi NAS: Automount LUKS-Encrypted drives using an USB key, consulté le février 1, 2026, https://xan105.com/blog/raspberry-pi-nas-automount-luks-encrypted-drives-using-an-usb-key
4.	Getting emergency mode if I try to auto mount an encrypted drive at boot, consulté le février 1, 2026, https://forums.raspberrypi.com/viewtopic.php?t=377033
5.	Concurrency when writing data into SQLite? : r/golang - Reddit, consulté le février 1, 2026, https://www.reddit.com/r/golang/comments/16xswxd/concurrency_when_writing_data_into_sqlite/
6.	How many read connections when using concurrency? - SQLite User Forum, consulté le février 1, 2026, https://sqlite.org/forum/info/a7a8ca4d88b94fd558c47c11748e4d8886992cf9973f6604025e85adb66ba6b5
7.	WireGuard vs Cloudflare Tunnel | Which VPN Is Best? (2025) - YouTube, consulté le février 1, 2026, https://www.youtube.com/watch?v=cNHgf6f6dCY&vl=en-US
8.	WireGuard vs Cloudflare Tunnel : r/selfhosted - Reddit, consulté le février 1, 2026, https://www.reddit.com/r/selfhosted/comments/1le2nra/wireguard_vs_cloudflare_tunnel/
9.	Wireguard vs Cloudflare Tunnel - Which VPN Is Better? (2025) - YouTube, consulté le février 1, 2026, https://www.youtube.com/watch?v=BBdkKLVP4ZY
10.	Creating a Lightweight Linux Firewall with UFW and fail2ban - DEV Community, consulté le février 1, 2026, https://dev.to/caffinecoder54/creating-a-lightweight-linux-firewall-with-ufw-and-fail2ban-35po
11.	Hardening My Raspberry Pi: Building a Secure Home Lab From Scratch - Medium, consulté le février 1, 2026, https://medium.com/@the0xmatchaberry/hardening-my-raspberry-pi-building-a-secure-home-lab-from-scratch-9007dc938cbf
12.	How to Setup Fail2ban on the Raspberry Pi - Pi My Life Up, consulté le février 1, 2026, https://pimylifeup.com/raspberry-pi-fail2ban/
13.	Home Office Security: Secure Headless Raspberry Pi Setup with SSH Keys, Firewall, Fail2Ban, PSAD, and Google Authenticator | by HRK | Medium, consulté le février 1, 2026, https://medium.com/@hhrk/home-office-security-secure-headless-raspberry-pi-setup-with-ssh-keys-firewall-fail2ban-psad-4c02e8ce4123
14.	{Basic Tutorial} How to harden a Raspberry Pi for self hosting : r/raspberry_pi - Reddit, consulté le février 1, 2026, https://www.reddit.com/r/raspberry_pi/comments/hc2xr3/basic_tutorial_how_to_harden_a_raspberry_pi_for/
15.	How to Create Two‑Factor Authentication (2FA) and Best Practices - DEV Community, consulté le février 1, 2026, https://dev.to/wesleyisr4/how-to-create-two-factor-authentication-2fa-and-best-practices-4mjl
16.	Google drive - Rclone, consulté le février 1, 2026, https://rclone.org/drive/
17.	Setup rclone to backup to Google Drive on Raspberry Pi - GitHub Gist, consulté le février 1, 2026, https://gist.github.com/sissbruecker/c9263e237f5972e25d9d84b71dd89292
18.	A Guide for Setting Up an Rclone Encrypted Remote with Google Workspace for Plex on Windows 10 - Reddit, consulté le février 1, 2026, https://www.reddit.com/r/PleX/comments/rrh29f/a_guide_for_setting_up_an_rclone_encrypted_remote/
